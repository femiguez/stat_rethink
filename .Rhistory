se.y <- sd(y)/sqrt(length(y))
dy <- function(y, mu, sigma) -2 * sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
thetas <- seq(10, 20, by = 0.5)
LL <- sapply(1:length(thetas), function(i) dy(y = y, mu = thetas[i], sigma = sd(y)))
plot(thetas, LL, type = "l", xlab = "theta", ylab = "-2 log-likelihood")
set.seed(5678)
y <- rnorm(20, 15, 2)
mean.y <- mean(y)
se.y <- sd(y)/sqrt(length(y))
dy <- function(y, mu, sigma) -2 * sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
thetas <- seq(10, 20, by = 0.5)
LL <- sapply(1:length(thetas), function(i) dy(y = y, mu = thetas[i], sigma = sd(y)))
plot(thetas, LL, type = "l", xlab = "theta", ylab = "-2 log-likelihood")
set.seed(1)
y <- rnorm(20, 15, 2)
mean.y <- mean(y)
se.y <- sd(y)/sqrt(length(y))
dy <- function(y, mu, sigma) -2 * sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
thetas <- seq(10, 20, by = 0.5)
LL <- sapply(1:length(thetas), function(i) dy(y = y, mu = thetas[i], sigma = sd(y)))
plot(thetas, LL, type = "l", xlab = "theta", ylab = "-2 log-likelihood")
## This next function calculates the minus 2 log-likelihood
m2LL <- function(cfs, y) -2 * sum(dnorm(y, mean = cfs[1], sd = cfs[2], log = TRUE))
m2LL.op <- optim(c(1,1), m2LL, y = y, hessian = TRUE)
m2LL.op
## From the Hessian we can calculate the standard error for the mean
m2LL.se.mu <- sqrt(solve(m2LL.op$hessian)[1,1] * m2LL.op$par[2])
## This shows that we can obtain the precision for mu using maximum
## likelihood, but we need to calculate the Hessian
print(list(se.y = se.y, m2LL.se.mu = m2LL.se.mu))
set.seed(12)
y <- rnorm(20, 15, 2)
mean.y <- mean(y)
se.y <- sd(y)/sqrt(length(y))
dy <- function(y, mu, sigma) -2 * sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
thetas <- seq(10, 20, by = 0.5)
LL <- sapply(1:length(thetas), function(i) dy(y = y, mu = thetas[i], sigma = sd(y)))
plot(thetas, LL, type = "l", xlab = "theta", ylab = "-2 log-likelihood")
m2LL <- function(cfs, y) -2 * sum(dnorm(y, mean = cfs[1], sd = cfs[2], log = TRUE))
m2LL.op <- optim(c(1,1), m2LL, y = y, hessian = TRUE)
m2LL.op
## From the Hessian we can calculate the standard error for the mean
m2LL.se.mu <- sqrt(solve(m2LL.op$hessian)[1,1] * m2LL.op$par[2])
## This shows that we can obtain the precision for mu using maximum
## likelihood, but we need to calculate the Hessian
print(list(se.y = se.y, m2LL.se.mu = m2LL.se.mu))
set.seed(123)
y <- rnorm(20, 15, 2)
mean.y <- mean(y)
se.y <- sd(y)/sqrt(length(y))
dy <- function(y, mu, sigma) -2 * sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
thetas <- seq(10, 20, by = 0.5)
LL <- sapply(1:length(thetas), function(i) dy(y = y, mu = thetas[i], sigma = sd(y)))
plot(thetas, LL, type = "l", xlab = "theta", ylab = "-2 log-likelihood")
m2LL <- function(cfs, y) -2 * sum(dnorm(y, mean = cfs[1], sd = cfs[2], log = TRUE))
m2LL.op <- optim(c(1,1), m2LL, y = y, hessian = TRUE)
m2LL.op
## From the Hessian we can calculate the standard error for the mean
m2LL.se.mu <- sqrt(solve(m2LL.op$hessian)[1,1] * m2LL.op$par[2])
## This shows that we can obtain the precision for mu using maximum
## likelihood, but we need to calculate the Hessian
print(list(se.y = se.y, m2LL.se.mu = m2LL.se.mu))
?boot_lm
require(car)
data(barley, package = "nlraa")
## Fit a linear model (quadratic)
fit.lm <- lm(yield ~ NF + I(NF^2), data = barley)
## Bootstrap coefficients by default
fit.lm.bt <- boot_lm(fit.lm)
confint(fit.lm)
fit.lm.bt <- boot_lm(fit.lm, psim = 4)
confint(fit.lm.bt)
y <- rnorm(20, 15, 3)
confint(lm(y ~ 1))
dat <- data.frame(y = y)
confint(boot_lm(lm(y ~ 1, data = dat)))
confint(boot_lm(lm(y ~ 1, data = dat), psim = 4))
confint(boot_lm(lm(y ~ 1, data = dat), resid.type = "n"))
confint(boot_lm(lm(y ~ 1, data = dat), resid.type = "normal"))
confint(lm(y ~ 1))
confint(boot_lm(lm(y ~ 1, data = dat), resid.type = "normal", psim = 4))
fit.sa <- rstanarm::stan_lm(y ~ 1, data = dat)
fit.sa <- rstanarm::stan_glm(y ~ 1, data = dat)
predictive_interval(fit.sa)
colMeans(predictive_interval(fit.sa))
confint(boot_lm(lm(y ~ 1, data = dat)))
confint(boot_lm(lm(y ~ 1, data = dat)), type = "perc")
confint(boot_lm(lm(y ~ 1, data = dat, psim = 3)), type = "perc")
library(brms)
fm.br <- brm(y ~ 1, data = dat)
predictive_interval(fm.br)
posterior_interval(fm.br)
posterior_epred(fm.br)
posterior_summary(posterior_epred(fm.br))
posterior_interval(fm.br)
posterior_interval(fm.br)
predictive_interval(fm.br)
fm0 <- lm(y ~ 1, data = dat)
fm0.bt <- boot_lm(fm0, psim = 2)
confint(fm0.bt)
fm0.sim <- simulate_lm(fm0, nsim = 1e3, psim = 3)
dim(fm0.sim)
quantile(c(fm0.sim), probs = c(0.025, 0.975))
fm0.sim <- simulate_lm(fm0, nsim = 1e4, psim = 3)
quantile(c(fm0.sim), probs = c(0.025, 0.975))
library(predintma)
pdi <- pred_int(dat$y)
pdi
?pred_int
pdi.bt <- pred_int(dat$y, method = "boot")
pdi.bt <- pred_int_boot(dat$y)
?pred_int_boot
pdi.bt <- pred_int(dat$y, method = "conformal")
pdi.bt
?pred_int
?pred_int_boot
?boot_tmeans
pred_int
library(predintma)
require(ggplot2)
data(soyrs)
## Simply calculate the trial means
tmns <- aggregate(lrr ~ Trial_ID, data = soyrs, FUN = mean)
## Bootstrapped stratified trial means
btm <- boot_tmeans(lrr ~ Trial_ID, data = soyrs, R = 2e3)
pdi.cf <- pred_int_conformal_df(formula = lrr ~ Trial_ID, x = soyrs)
btmd <- btm$dat
btm.q <- btm$pdi
ggplot() + xlab("lrr") +
geom_density(data = btmd, aes(x = ys)) +
geom_jitter(data = soyrs, aes(x = lrr, y = 2.5)) +
geom_jitter(data = tmns, aes(x = lrr, y = 5), color = "blue", size = 1.2) +
geom_point(aes(x = pdi.cf[1], y = -1), color = "orange", size = 1.2) +
geom_errorbarh(mapping = aes(xmin = pdi.cf[2], xmax = pdi.cf[3],
y = -1), color = "orange", size = 1.2) +
geom_point(aes(x = btm.q[1], y = -2), color = "red", size = 1.2) +
geom_errorbarh(aes(xmin = btm.q[2], xmax = btm.q[3], y = -2),
color = "red", size = 1.2)
library(rethinking)
?ulam
library(brms)
?brm
library(kable)
library(knitr)
tillage <- c("NT","CT")
fertilizer <- c("0 N kg/ha","100 N kg/ha")
## They are crossed, so all levels are combined
exp.design <- expand.grid(tillage = tillage, fertilizer = fertilizer)
kable(exp.design)
?matrix
exp.design.mat <- matrix(c("NT - 0 N kg/ha", "CT - 0 N kg/ha",
"NT - 100 N kg/ha", "CT - 100 kg/ha"),
dimnames = list(c("fertilizer", "tillage"),
c("NT","CT")))
exp.design.mat <- matrix(c("NT - 0 N kg/ha", "CT - 0 N kg/ha",
"NT - 100 N kg/ha", "CT - 100 kg/ha"),
nrow = 2,
dimnames = list(c("fertilizer", "tillage"),
)
)
exp.design.mat <- matrix(c("NT - 0 N kg/ha", "CT - 0 N kg/ha",
"NT - 100 N kg/ha", "CT - 100 kg/ha"),
nrow = 2,
dimnames = list(c("fertilizer", "tillage"),
c("NT","CT")))
exp.design.mat
exp.design.mat <- matrix(c("NT - 0 N kg/ha", "CT - 0 N kg/ha",
"NT - 100 N kg/ha", "CT - 100 kg/ha"),
nrow = 2,
dimnames = list(c("NT", "CT"),
c("0 N kg/ha","100 N kg/ha")))
kable(exp.design.mat)
sites <- c("A","B","C")
blocks <- 1:4
site_block <- paste(sites, block, sep = "_")
sites <- c("A","B","C")
blocks <- 1:4
site_block <- paste(sites, blocks, sep = "_")
site_block
sites:blocks
sites:as.factor(blocks)
blocks_and_sites <- expand.grid(site = sites, block = blocks)
blocks_and_sites
sites <- c("A","B","C")
blocks <- 1:4
exp.design.nested <- expand.grid(site = sites, block = blocks)
exp.design.nested.levels <- with(exp.design.nested, paste(site, block, sep = "_"))
kable(exp.design.nested.levels)
?kable
kable(exp.design.nested.levels, label = "levels")
kable(exp.design.nested.levels, caption = "levels")
exp.design.nested.levels
library(ggplot2)
dat <- data.frame(x = xx, y = yy)
xx <- 1:20
yy <- 3 + 1.5 * xx + rnorm(length(xx))
dat <- data.frame(x = xx, y = yy)
ggplot(data = dat, aes(x = x, y = y)) +
geom_point()
fit <- lm(y ~ x, data = dat)
fit
vcov(fit)
cov2cor(vcov(fit))
library(nlraa)
fit.s <- simulate_lm(fit, nsim = 50)
fit.s <- simulate_lm(fit, nsim = 50, value = "data.frame")
head(fit.s)
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(y = sim.y, groups = ii))
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_point() +
geom_line(aes(y = sim.y, group = ii), color = "gray")
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_line(aes(y = sim.y, group = ii), color = "gray", alpha = 0.3) +
geom_point()
fit.s <- simulate_lm(fit, nsim = 10, value = "data.frame")
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_line(aes(y = sim.y, group = ii), color = "purple", alpha = 0.3) +
geom_point()
fit.s <- simulate_lm(fit, nsim = 5, value = "data.frame")
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_line(aes(y = sim.y, group = ii), color = "purple", alpha = 0.3) +
geom_point()
set.seed(1234)
fit.s <- simulate_lm(fit, nsim = 5, value = "data.frame")
ggplot(data = fit.s, aes(x = x, y = y)) +
geom_line(aes(y = sim.y, group = ii), color = "purple", alpha = 0.3) +
geom_point()
fit.b <- boot_lm(fit)
library(car)
hist(fit.b, 1)
hist(fit.b, 2)
hist(fit.b, 1, ci = "perc")
hist(fit.b, 2, ci = "perc")
names(fit.b)
plot(fit.b$t)
plot(fit.b$t, xlab = "Intercept", ylab = "Slope")
?MASS:mvrnorm
?MASS:rmvnorm
?MASS::rmvnorm
?MASS::mvrnorm
library(brms)
?brm
priors <- prior(normal(0, 4)) +
prior(normal(0, 4))
## Fit model
fbrms <- brm(y ~ x, data = dat, prior = priors)
priors <- prior(normal(0, 4))
## Fit model
fbrms <- brm(y ~ x, data = dat, prior = priors)
fbrms
prior_summary(fbrms)
priors <- prior(normal(0, 4), class = "Intercept") +
prior(normal(0, 4), coef = "x")
## Fit model
fbrms <- brm(y ~ x, data = dat, prior = priors)
prior_summary(fbrms)
fbrms
priors <- prior(normal(0, 5), class = "Intercept") +
prior(normal(0, 4), coef = "x")
## Fit model
fbrms <- brm(y ~ x, data = dat, prior = priors)
plot(fbrms, "_b")
plot(fbrms, "b_")
?brms
?extract_draws
plot.brmsfit
brms::plot.brmsfit
brms:::plot.brmsfit
?brms:::plot.brmsfit
?posterior_samples
ps <- posterior_samples(fbrms)
head(ps)
plot(ps[,1:2], xlab = "Intercept", ylab = "slope")
fbrms
vocv(fbrms)
vcov(fbrms)
cov2cor(vcov(fbrms))
?brm
fbrms <- brm(y ~ x, data = dat, prior = priors, refresh = 0)
data(package = "nlraa")
data(barley, package = "nlraa")
head(barley)
library(nlme)
barley$NF2 <- barley$NF^2
br.lme <- lme(yield ~ NF + NF2, random = ~ NF | year, data = barley)
br.lme
vcov(br.lme)
cov2cor(vcov(br.lme))
br.lme <- lme(yield ~ NF + NF2, random = ~ NF + NF2 | year, data = barley)
br.lme
fixef(br.lme)
fixef(br.lme)
## Variance-covariance for beta
vcov(br.lme)
cov2cor(vcov(br.lme))
prs <- prior(normal(100, 50), class = Intercept) +
prior(normal(50, 15), class = "b", coef = "NF") +
prior(normal(0, 5), class = "b", coef = "NF2")
## Fit the multilevel model
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0,
prior = prs)
prior_summary(br.brms)
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0,
prior = prs, control = list(adapt_delta = 0.95))
pairs(br.brms)
pairs(br.brms)
pairs(br.brms, "^b_")
pairs(fbrms, "^b_")
## Fit the multilevel model
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0,
prior = prs, control = list(adapt_delta = 0.99))
br.lme
intervals(br.lme)
plot(br.brms)
plot(br.brms, "^b_")
pairs(br.brms, "^b_")
prior_summary(br.brms)
?prior
prs <- prior(normal(100, 50), class = Intercept) +
prior(normal(50, 15), class = "b", coef = "NF") +
prior(normal(0, 5), class = "b", coef = "NF2") +
prior(exponential(1), class = "sd")
## Fit the multilevel model
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0,
prior = prs, control = list(adapt_delta = 0.99))
prior_summary(br.brms)
prs <- prior(normal(100, 50), class = Intercept) +
prior(normal(50, 15), class = "b", coef = "NF") +
prior(normal(0, 5), class = "b", coef = "NF2") +
prior(student_t(2, 0, 150), class = "sd")
## Fit the multilevel model
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0,
prior = prs, control = list(adapt_delta = 0.99))
?brm
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0, iter = 3000,
prior = prs, control = list(adapt_delta = 0.95,
max_treedepth = 15))
br.brms
pp_check(br.brms)
plot(conditional_effects(br.brms))
plot(conditional_effects(br.brms), points = TRUE)
?conditional_effects
plot(marginal_effects(br.brms), points = TRUE)
plot(conditional_effects(br.brms, effects = NF + NF2), points = TRUE)
plot(conditional_effects(br.brms, effects = ~NF + NF2), points = TRUE)
plot(conditional_effects(br.brms, effects = "NF + NF2"), points = TRUE)
plot(conditional_effects(br.brms, effects = "NF:NF2"), points = TRUE)
plot(conditional_effects(br.brms, effects = "NF"), points = TRUE)
plot(posterior_predict(br.brms))
pp <- posterior_predict(br.brms)
head(pp)
pp <- predict(br.brms)
head(pp)
dim(pp)
pp2 <- cbind(barley, pp)
head(pp2)
ggplot(data = pp2, aes(NF, yield)) +
facet_wrap(~year) +
geom_line(aes(y = Estimate))
ggplot(data = pp2, aes(NF, yield)) +
geom_point() +
facet_wrap(~year) +
geom_line(aes(y = Estimate))
ggplot(data = pp2, aes(NF, yield)) +
geom_point() +
facet_wrap(~year) +
geom_line(aes(y = Estimate)) +
geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), color = "purple", alpha = 0.3)
ggplot(data = pp2, aes(NF, yield)) +
geom_point() +
facet_wrap(~year) +
geom_line(aes(y = Estimate)) +
geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5), fill = "purple", alpha = 0.3)
br.brms <- brm(yield ~ NF + NF2 + (NF + NF2 | year),
data = barley, refresh = 0, iter = 10000,
prior = prs, control = list(adapt_delta = 0.95,
max_treedepth = 15))
?predict.brmsfit
library(nlraa)
?var_cov
data(ChickWeight)
fit4 <- gls(weight ~ Time, data = ChickWeight,
weights = varPower(),
correlation = corCAR1(form = ~ Time | Chick))
v4 <- var_cov(fit4)
## Tip: you can visualize these matrices using
image(log(v4[,ncol(v4):1]))
library(nlme)
library(nlraa)
data(ChickWeight)
fit4 <- gls(weight ~ Time, data = ChickWeight,
weights = varPower(),
correlation = corCAR1(form = ~ Time | Chick))
v4 <- var_cov(fit4)
## Tip: you can visualize these matrices using
image(log(v4[,ncol(v4):1]))
v42 <- v4[1:30, 1:30]
image(log(v42[,ncol(v42):1]))
v42 <- v4[1:40, 1:40]
image(log(v42[,ncol(v42):1]))
v42 <- v4[1:35, 1:35]
image(log(v42[,ncol(v42):1]))
v42 <- v4[1:36, 1:36]
image(log(v42[,ncol(v42):1]))
ggplot(data = ChickWeight, aes(Time, weight)) +
geom_point()
library(ggplot2)
ggplot(data = ChickWeight, aes(Time, weight)) +
geom_point()
ggplot(data = ChickWeight, aes(Time, weight, color = Chick)) +
geom_point()
ggplot(data = ChickWeight, aes(Time, weight, color = Chick)) +
geom_point() +
theme(legend.position = "none")
fm1 <- lm(weight ~ Time, data = ChieckWeight)
fm1 <- lm(weight ~ Time, data = ChickWeight)
ggplot(data = ChickWeight, aes(Time, weight, color = Chick)) +
geom_point() +
geom_line(aes(y = fitted(fm1))) +
theme(legend.position = "none")
ggplot(data = ChickWeight, aes(Time, weight, color = Chick)) +
geom_point() +
geom_line(aes(y = fitted(fm1)), color = "black") +
theme(legend.position = "none")
dim(ChickWeight)
v4[1:15, 1:15]
round(v4[1:12, 1:12])
head(ChickWeight, 12)
cov2cor(v4[1:12, 1:12])
round(cov2cor(v4[1:12, 1:12]), 2)
?varPower
fit4
?corCAR1
1/3 * 0.5 + 1/3
(1/3 * 0.5) + 1/3
(0.5 * 0.5) + 0.5
library(nlraa)
library(ggplot2)
xx <- seq(0, 350, length.out = 10)
yy <- quadp(rep(xx, 10), 5, 40, -0.6, 250) + rnorm(100)
dat <- data.frame(x = xx, y = yy)
## Visualize
ggplot(data = dat, aes(x, y)) + geom_poin()
ggplot(data = dat, aes(x, y)) + geom_point()
xx <- seq(0, 350, length.out = 10)
yy <- quadp(rep(xx, 10), 5, 40, -0.06, 250) + rnorm(100)
dat <- data.frame(x = xx, y = yy)
## Visualize
ggplot(data = dat, aes(x, y)) + geom_point()
xx <- seq(0, 350, length.out = 10)
yy <- quadp(rep(xx, 10), 5000, 40, -0.06, 250) + rnorm(100)
dat <- data.frame(x = xx, y = yy)
## Visualize
ggplot(data = dat, aes(x, y)) + geom_point()
xx <- seq(0, 350, length.out = 10)
yy <- quadp(rep(xx, 10), 5000, 40, -0.06, 250) + rnorm(100, sd = 500)
dat <- data.frame(x = xx, y = yy)
## Visualize
ggplot(data = dat, aes(x, y)) + geom_point()
xx <- seq(0, 350, length.out = 10)
yy <- quadp(rep(xx, 10), 5000, 40, -0.06, 250) + rnorm(100, sd = 700)
dat <- data.frame(x = xx, y = yy)
## Visualize
ggplot(data = dat, aes(x, y)) + geom_point()
fit0 <- minpack.lm::nlsLM(y ~ SSquadp(x, a, b, c, xs), data = dat)
confint(fit0)
summary(fit0)
getInitial(y ~ SSquadp(x, a, b, c, xs), data = dat)
fit0 <- nlme::gnls(y ~ SSquadp(x, a, b, c, xs), data = dat)
fit0.bt <- car::Boot(fit0)
car::confint(fit0.bt)
library(car)
confint(fit0.bt)
dat.a <- aggregate(y ~ x, data = dat, FUN = mean)
dat.a
ggplot(data = dat.a, aes(x, y)) + geom_point()
fit0.a <- minpack.lm::nlsLM(y ~ SSquadp(x, a, b, c, xs), data = dat.a)
fit0.a
summary(fit0.a)
fit0.a.bt <- Boot(fit0.a, method = "residual")
confint(fit0.a.bt)
fit0.bt <- Boot(fit0)
## confidence intervals
confint(fit0.bt)
nlstools::confint2(fit0)
hist(fit0.bt)
ggplot(data = dat.a, aes(x, y)) +
geom_point() +
geom_line(aes(y = fitted(fit0.a)))
fit0$data
eval(fit0$data)$y
deviance(fit0)
fit0
r_squared <- function(x){
dt <- eval(x$data)
ss.y <- var(dt$y) * (length(dt$y) - 1)
ans <- (ss.y - deviance(x))/ss.y
}
r_squared(fit0)
fit0.rsq <- r_squared(fit0)
fit0.rsq
(fit0.rsq <- r_squared(fit0))
(fit0.a.rsq <- r_squared(fit0.a))
?Boot
